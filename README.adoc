Table of Contents
------------------

. Introduction
. Installation
. Configuration
. How To Use
. Sample Code
. Change Log

:toc:


= Introduction

This plugin provides easy integration of Swagger with GRAILS. It is highly aligned with Swagger and its 2.0 specification, thereby creating a language-agnostic interface to REST APIs. This allows both humans and computers to discover and understand the capabilities of service without access to implementation details.

= Installation

Add repository and dependency in your *_build.gradle_* file using below lines:
[source,java]
-----------------
dependencies {
    compile 'org.grails.plugins:swagger:1.2.1'
}
-----------------

NOTE: Your host application logging might not work as per your expected logback config file. +
This is an issue with swagger servlet jar.
Issue has already been raised for this:- https://github.com/swagger-api/swagger-core/issues/1813[https://github.com/swagger-api/swagger-core/issues/1813] +
However, you can easily overcome this issue by explicitly setting the name of your logback configuration file in your *_build.gradle_* using:
[source,java]
---------
bootRun {
    jvmArgs = [
            "-Dlogging.config=${project.projectDir}/grails-app/conf/logback.groovy"
    ]
}
---------

NOTE: Alternatively, you can also pass the name of logback configuration file using JVM argumants or system properties as follow:
[source,java]
---------
java -Dlogback.configurationFile=/path/to/config.xml
---------

Please refer https://logback.qos.ch/manual/configuration.html#configFileProperty[this link] to know more about how to set logback config file location. +



= Configuration

By default, this plugin will add the following url mapping to host application:
[source,java]
---------
"/apidoc/$action?/$id?"(controller: "apiDoc", action: "getDocuments")
---------

This exposes an API from your application as <app-url-root>/apidoc to render Swagger API Documents.
You can override this mapping in *UrlMappings.groovy* file in host application's *_urlMapping.groovy_* file. +

NOTE: If your application is located behind a proxy that enables the required CORS headers then you need to enable CORS support too.

NOTE: Please read https://github.com/swagger-api/swagger-ui#testing-cors-support[this article] to know if CORS support needs to be enabled or not for your application.


= How To Use

. A set of annotations is used to generate swagger documentation. Please refer https://github.com/swagger-api/swagger-core/wiki/Annotations[this link] to know more about the available annotations. 
+
NOTE: Only annotations provided by swagger-core are supported and JAX-RS annotations are not supported.

. Annotate your controller class with annotation _@io.swagger.annotations.Api_ to make it available for documentation. For more details see sample code.

. Annotate your actions of controller with _@io.swagger.annotations.ApiOperation, @io.swagger.annotations.ApiResponses, @io.swagger.annotations.ApiImplicitParams_ to include various method level information in your documentation. *See next section to know more details about how to use these annotations.*
+
NOTE: The value corresponding to *“value”* attribute of *API* annotation present at class level and the value corresponding to *“nickname”* attribute of *“ApiOperation”* annotation present at method level when combined together, _it should form the relative end point provided in UrlMappings.groovy._ 
 *Refer to explanation below the provided sample.*
 
. If the *“value”* attribute of *“API”* annotation present at class label is not provided then it defaults to the controller name.
. The *“nickname”* attribute of *“ApiOperation”* annotation is also new and serves as unique name for the operation. If this is not provided this default to the method name
+
NOTE: If you are not explicitly providing the mapping of your actions defined in controller to the end points using *UrlMappings.groovy* file, you need not to bother about *“value”* attribute of *“API”* annotation present at *class* label and  *“nickname”* attribute of *“ApiOperation”* annotation present at *method* label. Its default value will work fine.

In addition to official Swagger annotations, this plugin also provides custom annotation:
[source,java]
------
@SwaggerApiGroup
------

This annotation can be applied to Grails controllers to split APIs to separate api groups in order to avoid a huge single json api document when there are a large number of controllers.

= Sample Code

Assume your *UrlMappings.groovy* class is as follow: +

[source,java]
-----------------
package testswaggerplugin

class UrlMappings {
   static mappings = {
       "/$controller/$action?/$id?(.$format)?" {
           constraints {
               // apply constraints here
           }
       }
       "/"(view: "/index")
       "500"(view: '/error')
       "404"(view: '/notFound')
       "/api/v1/city/$cityId"(controller: "city", action: "getCity", method: "GET")
       "/api/v1/city/list"(controller: "city", action: "getCityList", method: "GET")
       "/api/v1/city/createUpdate"(controller: "city", action: "createOrUpdateCity", method: "POST")
       "/api/v1/city/$cityId"(controller: "city", action: "deleteCity", method: "DELETE")
   }
}
-----------------

Then your swagger annotated *CityController.groovy* is as follow: +

[source,java]
-----------------
package testswaggerplugin

import dto.CityDTO
import dto.ResponseDTO
import grails.converters.JSON
import io.swagger.annotations.*
import swagger.SwaggerApiGroup

@Api(value = "/api/v1", tags = ["City"], description = "City Api's")
class CityController {

   static namespace = 'v1'

   @ApiOperation(
           value = "List Cities",
           nickname = "city/{cityId}",
           produces = "application/json",
           consumes = "application/json",
           httpMethod = "GET",
           response = ResponseDTO.class
           )
   @ApiResponses([
           @ApiResponse(code = 405, 
           message = "Method Not Allowed. Only GET is allowed"),
           
           @ApiResponse(code = 404, 
           message = "Method Not Found")
           ])
   @ApiImplicitParams([
           @ApiImplicitParam(name = "cityId",
           paramType = "path", 
           required = true, 
           value = "City Id", 
           dataType = "string"),
           
           @ApiImplicitParam(name = "applicationType",
           paramType = "header",
           required = true,
           defaultValue = "web", 
           value = "Application Types",
           dataType = "string"),
           
           @ApiImplicitParam(name = "Accept-Language",
           paramType = "header", 
           required = true,
           defaultValue = "en", 
           value = "Accept-Language",
           dataType = "string")
   ])
   def getCity(String cityId) {
      // Demonstrate how to use swagger annotation to generate documentation 
      // for method which accepts cityId as parameter provided in url path.
      
       render(new ResponseDTO(status: true, 
       message: "New Delhi", 
       data: ["key1": "value1", "key2": "value2"]) as JSON)
   }

   @ApiOperation(
           value = "List Cities",
           nickname = "city/list",
           produces = "application/json",
           consumes = "application/json",
           httpMethod = "GET",
           response = ResponseDTO.class
           )
   @ApiResponses([
           @ApiResponse(code = 405,
           message = "Method Not Allowed. Only GET is allowed"),
           
           @ApiResponse(code = 404, 
           message = "Method Not Found")
           ])
           
   @ApiImplicitParams([
           @ApiImplicitParam(name = "offset",
           paramType = "query", required = true, 
           value = "Offset", dataType = "integer"),
           
           @ApiImplicitParam(name = "limit", 
           paramType = "query",
           required = true, 
           value = "Max size",
           dataType = "integer"),
 
           @ApiImplicitParam(name = "applicationType", 
           paramType = "header", 
           required = true, 
           defaultValue = "web", 
           value = "Application Types", 
           dataType = "string"),
           
           @ApiImplicitParam(name = "Accept-Language", 
           paramType = "header", 
           required = true, 
           defaultValue = "en", 
           value = "Accept-Language", 
           dataType = "string")
   ])
   def getCityList(Integer offset, Integer limit) {
      // Demonstrate how to use swagger annotation to generate documentation 
      // for method which accepts offset and limit as query parameter.
       render(new ResponseDTO(status: true, 
       message: "City List fetched successfully",
       data: ["key1": "value1", "key2": "value2"]) as JSON)
   }

   @ApiOperation(
           value = "Create City",
           notes = "Creates a new City. Accepts a City json.",
           produces = "application/json",
           consumes = "application/json",
           httpMethod = "POST",
           nickname = "/city/createUpdate",
           response = ResponseDTO.class
           )
   @ApiResponses([
           @ApiResponse(code = 405, 
           message = "Method Not Allowed. Only POST is allowed"),
           
           @ApiResponse(code = 404, 
           message = "Method Not Found")
   ])
   @ApiImplicitParams([
           @ApiImplicitParam(name = "body", 
           paramType = "body", 
           required = true, 
           value = "Requires City Details", 
           dataType = "dto.CityDTO"),
           
           @ApiImplicitParam(name = "applicationType",
           paramType = "header", 
           required = true, 
           defaultValue = "web", 
           value = "Application Types", 
           dataType = "string"),
           
           @ApiImplicitParam(name = "Accept-Language",
           paramType = "header",
           required = true, 
           defaultValue = "en",
           value = "Accept-Language", 
           dataType = "string")
   ])
   def createOrUpdateCity(CityDTO cityDTO) {
       render(new ResponseDTO(status: true, 
       message: "City updated successfully", 
       data: cityDTO) as JSON)
   }

   @ApiOperation(
           value = "Delete City",
           notes = "Deletes a City.Accepts a City ID .",
           produces = "application/json",
           consumes = "application/json",
           httpMethod = "DELETE",
           nickname = "/city/{cityId}",
           response = ResponseDTO.class
           )
   @ApiResponses([
           @ApiResponse(code = 405, 
           message = "Method Not Allowed. Only Delete is allowed"),
           @ApiResponse(code = 404, 
           message = "Method Not Found")])
           
   @ApiImplicitParams([
           @ApiImplicitParam(name = 'cityId',
           paramType = 'path', 
           required = true, value = "Requires City id for delete", 
           dataType = "string"),
           
           @ApiImplicitParam(name = "applicationType", 
           paramType = "header", 
           required = true, 
           defaultValue = "web", 
           value = "Application Types", 
           dataType = "string"),
           
           @ApiImplicitParam(name = "Accept-Language", 
           paramType = "header", 
           required = true, 
           defaultValue = "en", 
           value = "Accept-Language", 
           dataType = "string")
   ])
   def deleteCity(String cityId) {
       render(new ResponseDTO(status: true,
       message: "City deleted successfully") as JSON)
   }
}
-----------------
In the sample code provided above you can find that *CityController* is annotated with *@Api(value = "/api/v1", tags = ["City"], description = "City Api's")*.  So the value corresponding to *“value”* attribute of *“API”* annotation present at this class label is *"/api/v1"*. + 

Similarly you can observe that *getCity()* method of *CityController* has annotation *@ApiOperation(value = "List Cities",  nickname = "city/{cityId}", produces = "application/json", consumes = "application/json",  httpMethod = "GET", response = ResponseDTO.class)*. Hence the value corresponding to *“nickname”* attribute of *“ApiOperation”* annotation present at this method label is *"city/{cityId}"*  and when these two values of *API* annotation and *ApiOperation* annotations are combined together it gives *"/api/v1/city/{cityId}"*. +

This combined value is Swagger's way of specifying the end url- *"/api/v1/city/$cityId"*  defined in *UrlMappings.groovy* file for *(controller: "city", action: "getCity", method: "GET")* +

If this controller's endpoints need to be in a separate json doc with a specific url, the @SwaggerApiGroup annotation can be added to the controller, for example:
[source,java]
------
@SwaggerApiGroup('MyApiGroup')
@Api(...)
class CityController {
...
------

With the annotation above, the swagger API document is separate from the global document and available with uri: '<root-url>/apidoc/group/MyApiGroup',



= Change Log

- v 1.2.2: Add annotation based API grouping to split large global json document to multiple modular ones.

- v 1.2.1: Enhance the Object to Json Serializer to strip Grails Gorm traits such as Spring validation Errors type.

- v 1.2.0: Plugin support Grails 3+


